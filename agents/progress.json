{
  "issues": [
    {
      "name": "Host-Schema Tables (River-style)",
      "tasks": [
        "[x] Rename task table to `embedding_tasks`",
        "[x] Remove `CREATE SCHEMA IF NOT EXISTS embeddingkit` from migrations; create tables in host schema via search_path",
        "[x] Update `tasks.Repo` to target `<schema>.embedding_tasks`",
        "[x] Add `embedding_vectors` table + HNSW index + pgvector extension in embeddingkit migrations",
        "[x] Use `entity_id text` in `embedding_tasks` + `embedding_vectors` so apps can use bigint/uuid/anything"
      ]
    },
    {
      "name": "Use migratekit For Postgres Migrations",
      "tasks": [
        "[x] Add a Postgres migrator option in `~/migratekit` to run migrations under a specific schema via `SET LOCAL search_path` (e.g. `WithSearchPath(schema)` or `WithSchema(schema)`); keep `public.migrations` tracking unchanged",
        "[x] Ensure the schema name is safely quoted/validated (no SQL injection) and default `search_path = <schema>, public`",
        "[x] Tag + push migratekit",
        "[x] Document the migration source contract in `README.md` (host uses `LoadFromFS(migrations.Postgres)` + `NewPostgres(...).WithSchema(...).ApplyMigrations(...)`)",
        "[x] Update `README.md` with the canonical migratekit integration snippet (apply + validate)"
      ]
    },
    {
      "name": "VL Embeddings (Hosted API; URL-only; Provider TBD)",
      "tasks": [
        "[x] Define canonical VL contract: URL-only, fused single-vector per entity/query (no per-asset vectors in v1)",
        "[x] Define hard limits at the library boundary (MaxAssets in config; caller supplies URLs; provider-specific size limits are out of scope)",
        "[x] Extend `embeddingkit/vl` with a URL-only fused embed interface that accepts (text + N image/frame URLs and optionally a single video URL) and returns ONE vector",
        "[x] Enforce URL-only inputs end-to-end (no raw bytes uploads); AssetFetcher returns URLs only; Runtime requires URL-only VL embedder",
        "[x] Provide a fusion helper for chunk-level fusion (avg + L2 normalize) when inputs are chunked",
        "[x] Add a provider adapter slot for a future hosted Qwen3-VL-Embedding endpoint (URL-only inputs)",
        "[x] Ensure model registry supports multiple VL models (2B/8B) at native dims without schema changes",
        "[x] Document expected Postgres schema pattern for storing VL vectors (row-based, halfvec, HNSW; optional 2-stage)",
        "[x] Document how apps switch active VL model and how to backfill safely"
      ]
    },
    {
      "name": "Core Library Tasks",
      "tasks": [
        "[x] OpenAI-compatible embedding client (text) + model metadata",
        "[x] `pg` helpers for halfvec cosine similarity/distance",
        "[x] 2-stage retrieval helper: binary_quantize oversample + halfvec rescoring",
        "[x] Generic embedding task repo for `embedding_tasks`",
        "[x] Remove River adapter from embeddingkit (job-system agnostic)",
        "[x] Add canonical vector-search API over `embedding_vectors` (SearchVectors / SimilarTo)",
        "[x] Support 1-stage cosine KNN and optional 2-stage (binary_quantize oversample + halfvec rescore) in that API",
        "[x] Add query options: entity_types filter, min_similarity, oversample_factor, limit, exclude_ids, and optional extra WHERE fragment + args",
        "[x] Return only candidates (entity_type, entity_id, model, similarity) — no hydration/business logic",
        "[x] Document non-River runner loop contract (FetchReady → Work → Complete/Fail)",
        "[x] Add post-processing helpers (MMR / generic diversity caps) without domain assumptions",
        "[x] Add an evaluation harness skeleton (apps supply queries + expected IDs)"
      ]
    }
  ]
}
